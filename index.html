<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mic Check - Test Your Microphone Quality for Video Calls</title>
    <link rel="canonical" href="https://mic-check.mbdr.ai">

    <!-- Favicon -->
    <link rel="icon" href="favicon.svg" type="image/svg+xml">

    <!-- SEO and Social Media Meta Tags -->
    <meta name="description" content="Record and test your microphone quality for video calls, online meetings, and recordings. Instant playback with audio visualization to ensure clear audio.">
    <meta name="keywords" content="microphone test, mic check, audio quality, video calls, online meetings, voice recording, audio visualization">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mic-check.mbdr.ai"> 
    <meta property="og:title" content="Mic Check - Test Your Microphone Quality">
    <meta property="og:description" content="Record and test your microphone quality for video calls, online meetings, and recordings with instant playback and audio visualization.">
    <meta property="og:image" content="assets/og.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://mic-check.mbdr.ai">
    <meta property="twitter:title" content="Mic Check - Test Your Microphone Quality">
    <meta property="twitter:description" content="Record and test your microphone quality for video calls, online meetings, and recordings with instant playback and audio visualization.">
    <meta property="twitter:image" content="assets/og.png">

    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Mic Check",
      "url": "https://mic-check.mbdr.ai",
      "description": "A web application that allows users to record and test their microphone quality for video calls, online meetings, and recordings with instant playback and audio visualization.",
      "applicationCategory": "MultimediaApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "creator": {
        "@type": "Person",
        "name": "Megan Ruthven"
      },
      "keywords": "microphone test, mic check, audio quality, video calls, online meetings, voice recording",
      "inLanguage": "en",
      "datePublished": "2025-04-01",
      "featureList": "Microphone selection, Audio recording, Playback controls, Audio visualization, Spectrogram analysis"
    }
    </script>

    <!-- Google tag (gtag.js) - GA4 -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-6P5YEMZ84D"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      // Set default consent to 'denied' before GA4 config
      gtag('consent', 'default', {
        'analytics_storage': 'denied',
        'ad_storage': 'denied',
        'wait_for_update': 500 // Milliseconds to wait for update before sending hits
      });

      gtag('config', 'G-6P5YEMZ84D');
    </script>

    <style>
        /* Basic Reset */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #2980b9, #27ae60);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            color: #ffffff;
        }

        /* Main Application Window - Glassmorphic Style */
        .app-window {
            background-color: rgba(255, 255, 255, 0.2); 
            backdrop-filter: blur(18px); 
            border: 1px solid rgba(255, 255, 255, 0.32);
            border-radius: 26px; 
            box-shadow: 0 14px 50px rgba(8, 28, 62, 0.5); 
            width: 100%;
            max-width: 640px; 
            min-height: 780px; 
            display: flex;
            flex-direction: column;
            padding: 40px; 
        }

        .app-title {
            font-size: 38px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 15px; /* Reduced margin to make space for blurb */
            color: #ffffff;
            text-shadow: 0 4px 8px rgba(0,0,0,0.38);
        }
        .app-blurb { /* New style for the introductory blurb */
            font-size: 15px;
            font-weight: 400;
            text-align: center;
            color: rgba(255, 255, 255, 0.85);
            margin-bottom: 30px; /* Space before the next section */
            max-width: 80%; /* Keep it from being too wide */
            margin-left: auto;
            margin-right: auto;
        }

        /* Control Sections - Glassmorphic Style */
        .control-section {
            background-color: rgba(255, 255, 255, 0.16); 
            border-radius: 22px;
            padding: 26px; 
            margin-bottom: 26px;
            box-shadow: 0 7px 25px rgba(0,0,0,0.16);
            border: 1px solid rgba(255, 255, 255, 0.25);
        }

        .section-title-div { 
            font-size: 21px;
            font-weight: 500;
            color: #fafafa; 
            padding-bottom: 14px; 
            margin-bottom: 22px; 
            border-bottom: 1px solid rgba(255,255,255,0.3); 
            width: 100%; 
        }
        
        .subsection-heading {
            font-size: 18px;
            font-weight: 500;
            color: #e8e8e8;
            margin-top: 10px; 
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        .info-icon {
            display: inline-block;
            width: 18px; 
            height: 18px;
            border: 1.5px solid #e0e0e0; 
            border-radius: 50%;
            text-align: center;
            line-height: 15px; 
            font-size: 11px; 
            font-weight: bold;
            color: #e0e0e0;
            margin-left: 8px;
            cursor: help;
            position: relative; 
        }
        .tooltip {
            visibility: hidden;
            width: 280px; 
            background-color: rgba(20, 20, 20, 0.9); 
            color: #f0f0f0; 
            text-align: left;
            border-radius: 8px; 
            padding: 12px;
            position: absolute;
            z-index: 10; 
            bottom: 130%; 
            left: 50%;
            margin-left: -140px; 
            opacity: 0;
            transition: opacity 0.3s ease-in-out, visibility 0s 0.3s linear; 
            font-size: 13.5px; 
            line-height: 1.6;
            box-shadow: 0 3px 10px rgba(0,0,0,0.4);
        }
        .tooltip::after { 
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px; 
            border-width: 6px;
            border-style: solid;
            border-color: rgba(20, 20, 20, 0.9) transparent transparent transparent;
        }
        .info-icon:hover .tooltip {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }
        
        select { 
            width: 100%;
            padding: 15px 22px;
            border: 1px solid rgba(255, 255, 255, 0.45);
            background-color: rgba(0, 0, 0, 0.35);
            color: #ffffff;
            border-radius: 16px;
            font-size: 18px;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23f8f8f8'%3e%3cpath d='M7 10l5 5 5-5H7z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 22px center;
            background-size: 1.25em;
        }
        select option {
            background-color: #1a2b38;
            color: #ffffff;
        }


        /* Button Styling */
        .button-panel {
            display: flex;
            justify-content: center;
            margin-bottom: 26px;
        }

        .modern-button {
            background-color: rgba(255, 255, 255, 0.28);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.55);
            padding: 15px 32px;
            min-width: 180px;
            border-radius: 32px;
            cursor: pointer;
            font-size: 19px;
            font-weight: 500;
            text-align: center;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 5px 14px rgba(0,0,0,0.22);
        }
        .modern-button:disabled {
            background-color: rgba(127, 140, 141, 0.3);
            border-color: rgba(127, 140, 141, 0.15);
            color: rgba(255,255,255,0.35);
            cursor: not-allowed;
            box-shadow: none;
        }
        .modern-button:not(:disabled):hover {
            background-color: rgba(255, 255, 255, 0.38);
            box-shadow: 0 7px 20px rgba(0,0,0,0.28);
        }
        .modern-button:not(:disabled):active {
            background-color: rgba(255, 255, 255, 0.22);
            box-shadow: 0 3px 10px rgba(0,0,0,0.18);
            transform: translateY(1px);
        }
        .modern-button.recording {
             background-color: rgba(231, 76, 60, 0.45);
             border-color: rgba(231, 76, 60, 0.65);
        }
        .modern-button.recording:hover {
             background-color: rgba(231, 76, 60, 0.55);
        }


        /* Audio Player Styling & Spectrogram Canvas */
        .playback-section { }
        .playback-status { 
            text-align: center;
            font-size: 15px;
            color: #e0e0e0;
            margin-bottom: 10px;
            min-height: 20px; 
        }
        #spectrogramContainer { 
            position: relative;
            width: 100%;
            margin-bottom: 10px;
        }
        #spectrogramCanvas {
            display: block; 
            width: 100%; 
            height: 150px; 
            background-color: rgba(0,0,0,0.3); 
            border-radius: 10px;
        }
        audio {
            width: 100%;
            outline: none;
            background-color: transparent;
            border: none;
            margin-top: 10px; 
        }

        audio::-webkit-media-controls-panel {
            background-color: rgba(0, 0, 0, 0.4); 
            border: 1px solid rgba(255, 255, 255, 0.22); 
            border-radius: 16px; 
            padding: 14px 20px; 
            color: #f8f9fa; 
            transition: background-color 0.3s ease;
        }
         audio:hover::-webkit-media-controls-panel {
            background-color: rgba(0, 0, 0, 0.5); 
        }

        audio::-webkit-media-controls-play-button,
        audio::-webkit-media-controls-mute-button {
            background-color: rgba(255, 255, 255, 0.25); 
            border-radius: 50%;
            transition: background-color 0.2s ease;
            margin: 0 10px; 
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.3);
            color: white !important; 
            filter: brightness(1.1); 
        }
        audio::-webkit-media-controls-play-button:hover,
        audio::-webkit-media-controls-mute-button:hover {
            background-color: rgba(255, 255, 255, 0.35);
        }

        audio::-webkit-media-controls-timeline {
            background-color: rgba(255,255,255,0.2); 
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.25);
            margin: 0 16px; 
            height: 12px; 
        }
        audio::-webkit-media-controls-timeline::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px; 
            height: 20px;
            border-radius: 50%;
            background: #ffffff; 
            cursor: pointer;
            border: 2px solid rgba(0,0,0,0.25); 
            box-shadow: 0 0 10px rgba(255,255,255,0.5); 
        }

        audio::-webkit-media-controls-current-time-display,
        audio::-webkit-media-controls-time-remaining-display {
            color: #ffffff;
            text-shadow: 0 1px 5px rgba(0,0,0,0.7); 
            padding: 0 14px;
            font-size: 16px;
            font-weight: 500;
        }

        audio::-webkit-media-controls-volume-slider-container {
            padding: 0 12px;
        }
        audio::-webkit-media-controls-volume-slider {
            background-color: rgba(255,255,255,0.2);
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.25);
            height: 10px;
        }
        audio::-webkit-media-controls-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 1px solid rgba(0,0,0,0.2);
        }


        /* Visualizer */
        #visualizerContainer {
            width: 100%;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.28);
            border: 1px solid rgba(255, 255, 255, 0.28);
            border-radius: 16px;
            margin-bottom: 26px;
            display: flex;
            align-items: flex-end;
            padding: 10px;
            overflow: hidden;
        }
        .visualizer-bar {
            flex-grow: 1;
            background: linear-gradient(to top, rgba(46, 204, 113, 0.85), rgba(52, 152, 219, 0.85));
            margin: 0 2.2px;
            width: 2.5%; 
            height: 0%;
            border-radius: 6px 6px 0 0; 
            transition: height 0.05s linear;
        }

        /* Footer Styling */
        .footer-bar {
            text-align: center;
            padding: 15px;
            font-size: 14px; 
            color: #d0d0d0; 
            margin-top: auto; 
        }
        .footer-bar a {
            color: #d8d8d8; /* Subtle grey, slightly darker than white text */
            text-decoration: none;
            font-weight: 500; /* Slightly bolder to stand out a bit */
        }
        .footer-bar a:hover {
            text-decoration: underline;
            color: #ffffff;
        }

        /* Consent Banner Styling */
        .consent-banner {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(30, 30, 30, 0.85); /* Darker, slightly less transparent */
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 -8px 30px rgba(8, 28, 62, 0.45);
            padding: 20px 30px;
            z-index: 1000;
            display: flex; /* Ensure banner is a flex container by default */
            justify-content: space-between;
            align-items: center;
            color: #f0f0f0;
            font-size: 14px;
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
            transform: translateY(100%); /* Initially hidden (off-screen) */
            opacity: 0; /* Initially hidden (transparent) */
        }
        .consent-banner.show {
            transform: translateY(0);
            opacity: 1;
        }
        .consent-banner-text {
            margin-right: 20px;
            line-height: 1.6;
            flex-grow: 1; /* Allow text to take available space */
        }
        .consent-banner-text a {
            color: #d8d8d8; /* Subtle grey, slightly darker than white text */
            text-decoration: none;
        }
        .consent-banner-text a:hover {
            text-decoration: underline;
            color: #ffffff;
        }
        .consent-banner-buttons {
            display: flex; /* Arrange buttons in a row */
            flex-shrink: 0; /* Prevent button container from shrinking */
        }
        .consent-banner-buttons button {
            background-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 10px 20px;
            border-radius: 18px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-left: 10px;
            transition: background-color 0.2s ease;
        }
        .consent-banner-buttons button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        .consent-banner-buttons button.accept {
            background-color: rgba(46, 204, 113, 0.85); /* Match visualizer green */
            border-color: rgba(46, 204, 113, 0.95); /* Slightly more opaque border */
        }
        .consent-banner-buttons button.accept:hover {
            background-color: rgba(46, 204, 113, 0.95); /* Brighter green on hover */
        }

    </style>
</head>
<body>

    <div class="app-window">
        <h1 class="app-title">Mic Check</h1>
        <p class="app-blurb">Test your microphone quality to ensure clear audio during video calls, online meetings, and recordings. Record your voice, analyze the audio visualization, and experience instant playback to identify and fix sound issues.</p>


        <div class="control-section"> 
            <div class="section-title-div">Select Microphone</div>
            <select id="micSelect"></select>
        </div>

        <div id="visualizerContainer">
            </div>

        <div class="button-panel">
            <button id="toggleRecordButton" class="modern-button">Record</button>
        </div>

        <div class="control-section playback-section">
            <div class="section-title-div">Recording</div>
            <div class="playback-status" id="playbackStatus">Ready</div> 
            
            <div class="subsection-heading">
                Spectrogram
                <span class="info-icon">i
                    <span class="tooltip">This chart shows your sound's frequencies. Low pitches are at the bottom, high pitches at the top. Time moves from left to right. Brighter/warmer colors (like red) mean louder sounds for that frequency and time. The intensity (loudness) is shown on a logarithmic scale. This helps you see both very quiet and very loud sounds clearly. It's also important because low frequencies often have more power; logarithmic colors let you see details in the higher frequencies too, which might otherwise be hidden.</span>
                </span>
            </div>
            <div id="spectrogramContainer">
                 <canvas id="spectrogramCanvas"></canvas>
            </div>

            <div class="subsection-heading">Playback Controls</div>
            <audio id="audioPlayback" controls></audio>
        </div>
        
        <div class="footer-bar" id="footerBar"></div> 
    </div>

    <div class="consent-banner" id="consentBanner">
        <div class="consent-banner-text">
            This website uses cookies for analytics purposes to help us understand how visitors use our service. We only collect anonymous usage data if you consent. All microphone recordings are processed entirely in your browser and are never sent to any server. By clicking "Accept", you consent to the use of analytics cookies.
            <a href="https://github.com/mbdr-byte/mic-check" target="_blank" rel="noopener noreferrer">View Source Code</a> | 
            <a href="javascript:void(0);" id="privacyPolicyLink">Privacy Policy</a>
        </div>
        <div class="consent-banner-buttons">
            <button id="declineConsentButton">Decline All</button>
            <button id="acceptConsentButton" class="accept">Accept</button>
        </div>
    </div>
    
    <!-- Privacy Policy Modal -->
    <div id="privacyModal" style="display: none; position: fixed; z-index: 1100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); backdrop-filter: blur(5px);">
        <div style="background-color: rgba(40, 40, 40, 0.95); color: #f0f0f0; margin: 5% auto; padding: 30px; border: 1px solid rgba(255,255,255,0.2); border-radius: 20px; width: 80%; max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <h2 style="margin-top: 0; color: #ffffff;">Privacy Policy</h2>
            <p>Last Updated: April 2025</p>
            
            <h3>Overview</h3>
            <p>Mic Check is committed to protecting your privacy. This Privacy Policy explains how we collect, use, and safeguard your information when you visit our website.</p>
            
            <h3>Information We Collect</h3>
            <p><strong>Microphone Recordings:</strong> All audio recording and processing happens entirely in your web browser. We do not collect, transmit, or store any of your microphone recordings on our servers.</p>
            <p><strong>Analytics:</strong> With your consent, we collect anonymous usage data through Google Analytics 4 to understand how users interact with our website. This may include:</p>
            <ul style="margin-left: 20px;">
                <li>Pages visited and features used</li>
                <li>Time spent on the site</li>
                <li>Basic device information (browser type, operating system)</li>
                <li>Approximate geographic location (country/region only)</li>
            </ul>
            
            <h3>Cookies</h3>
            <p>We use cookies solely for the purpose of remembering your consent preferences and for analytics if you've provided consent.</p>
            
            <h3>Your Choices</h3>
            <p>You can control cookie preferences through the consent banner. Declining cookies will still allow you to use the site fully, but we won't collect any analytics data.</p>
            
            <h3>Contact</h3>
            <p>For any questions about this Privacy Policy, please visit <a href="https://mbdr.ai" style="color: #d8d8d8;">mbdr.ai</a>.</p>
            
            <button id="closePrivacyModal" style="background-color: rgba(46, 204, 113, 0.85); color: white; padding: 10px 20px; border: none; border-radius: 18px; cursor: pointer; margin-top: 20px;">Close</button>
        </div>
    </div>

    <script>
        const micSelect = document.getElementById('micSelect');
        const toggleRecordButton = document.getElementById('toggleRecordButton');
        const audioPlayback = document.getElementById('audioPlayback');
        const playbackStatus = document.getElementById('playbackStatus'); 
        
        const visualizerContainer = document.getElementById('visualizerContainer');
        const NUM_BARS = 40;

        const spectrogramCanvas = document.getElementById('spectrogramCanvas');
        const spectrogramCtx = spectrogramCanvas.getContext('2d');

        // GA4 Event Helper
        function sendGAEvent(eventName, eventParams) {
            if (typeof gtag === 'function') {
                gtag('event', eventName, eventParams);
            } else {
                console.warn('gtag function not found. Event not sent:', eventName, eventParams);
            }
        }

        let mediaRecorder;
        let audioChunks = [];
        let recordAudioContext; 
        let recordAnalyser; 
        let recordSourceNode; 
        let visualizerBars = [];
        let recordVisualizerAnimationFrameId; 
        
        let isRecording = false;
        let streamInstance = null;
        let currentAudioBlob = null; 

        const SPECTROGRAM_FFT_SIZE = 1024;

        for (let i = 0; i < NUM_BARS; i++) {
            const bar = document.createElement('div');
            bar.classList.add('visualizer-bar');
            visualizerContainer.appendChild(bar);
            visualizerBars.push(bar);
        }

        function setupSpectrogramCanvas() {
            spectrogramCanvas.width = Math.floor(spectrogramCanvas.clientWidth); 
            spectrogramCanvas.height = Math.floor(spectrogramCanvas.clientHeight);
            clearSpectrogram(); 
        }
        window.addEventListener('resize', setupSpectrogramCanvas);


        async function getMicrophones() {
            try {
                let tempStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                const devices = await navigator.mediaDevices.enumerateDevices();
                tempStream.getTracks().forEach(track => track.stop());

                const audioInputDevices = devices.filter(device => device.kind === 'audioinput');
                
                micSelect.innerHTML = ''; 
                if (audioInputDevices.length === 0) {
                    micSelect.innerHTML = '<option value="">No microphones found</option>';
                    toggleRecordButton.disabled = true;
                    playbackStatus.textContent = 'Error: No microphones found.';
                    return;
                }

                const microphones = new Map(); 
                let systemDefaultDeviceActualId = null;

                const defaultDeviceInfo = audioInputDevices.find(d => d.deviceId === 'default');
                if (defaultDeviceInfo) {
                    const sameGroupDevice = audioInputDevices.find(d => d.groupId === defaultDeviceInfo.groupId && d.deviceId !== 'default' && d.label);
                    if (sameGroupDevice) {
                        systemDefaultDeviceActualId = sameGroupDevice.deviceId;
                    } else { 
                        const firstNonDefaultLabeled = audioInputDevices.find(d => d.deviceId !== 'default' && d.label);
                        if (firstNonDefaultLabeled) {
                            systemDefaultDeviceActualId = firstNonDefaultLabeled.deviceId;
                        } else if (audioInputDevices.length > 1 && audioInputDevices[0].deviceId !== 'default') {
                            systemDefaultDeviceActualId = audioInputDevices.find(d => d.deviceId !== 'default')?.deviceId || null;
                        } else if (audioInputDevices.length === 1 && audioInputDevices[0].deviceId !== 'default') {
                            systemDefaultDeviceActualId = audioInputDevices[0].deviceId; 
                        }
                    }
                }


                audioInputDevices.forEach((device, index) => {
                    if (device.deviceId === 'default') return; 

                    let label = device.label || `Microphone ${index + 1}`;
                    const isDefault = device.deviceId === systemDefaultDeviceActualId;
                    
                    const baseLabel = label.replace(/\s*\((System )?Default\)\s*$/i, '').trim();

                    if (microphones.has(device.deviceId)) { 
                        if (isDefault && !microphones.get(device.deviceId).isSystemDefault) {
                            microphones.get(device.deviceId).label = `${baseLabel} (System Default)`;
                            microphones.get(device.deviceId).isSystemDefault = true;
                        }
                    } else { 
                        microphones.set(device.deviceId, {
                            label: isDefault ? `${baseLabel} (System Default)` : baseLabel,
                            deviceId: device.deviceId,
                            isSystemDefault: isDefault
                        });
                    }
                });
                
                let defaultSelectedInList = false;
                const sortedMicrophones = Array.from(microphones.values()).sort((a, b) => {
                    if (a.isSystemDefault && !b.isSystemDefault) return -1;
                    if (!a.isSystemDefault && b.isSystemDefault) return 1;
                    return a.label.localeCompare(b.label);
                });

                sortedMicrophones.forEach(micInfo => {
                    const option = document.createElement('option');
                    option.value = micInfo.deviceId;
                    option.text = micInfo.label;
                    if (micInfo.isSystemDefault) {
                        option.selected = true;
                        defaultSelectedInList = true;
                    }
                    micSelect.appendChild(option);
                });

                if (!defaultSelectedInList && micSelect.options.length > 0) {
                    micSelect.options[0].selected = true;
                }

                playbackStatus.textContent = 'Microphones loaded. Ready.';
                toggleRecordButton.disabled = false;
            } catch (err) {
                console.error('Error accessing media devices.', err);
                playbackStatus.textContent = 'Error: Mic access denied. Grant permission.';
                toggleRecordButton.disabled = true;
            }
        }
        
        async function handleToggleRecord() {
            if (isRecording) {
                sendGAEvent('record_action', {
                    'event_category': 'engagement',
                    'event_label': 'Stop Recording Button',
                    'action': 'stop_recording'
                });
                stopRecording();
            } else {
                sendGAEvent('record_action', {
                    'event_category': 'engagement',
                    'event_label': 'Start Recording Button',
                    'action': 'start_recording' 
                });
                await startRecording();
            }
        }

        async function startRecording() {
            if (!micSelect.value && micSelect.options.length > 0 && micSelect.options[0].value !== "") {
                micSelect.value = micSelect.options[0].value;
            } else if (!micSelect.value || (micSelect.options.length > 0 && micSelect.options[0].value === "")) {
                playbackStatus.textContent = 'Error: No microphone selected or available.';
                return;
            }
            
            clearSpectrogram(); 
            currentAudioBlob = null; 

            try {
                streamInstance = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        deviceId: { exact: micSelect.value },
                    },
                    video: false 
                });

                audioChunks = [];
                const options = { mimeType: 'audio/webm;codecs=opus' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'audio/webm'; 
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                         delete options.mimeType; 
                    }
                }
                mediaRecorder = new MediaRecorder(streamInstance, options);

                recordAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                recordAnalyser = recordAudioContext.createAnalyser();
                recordSourceNode = recordAudioContext.createMediaStreamSource(streamInstance);
                recordSourceNode.connect(recordAnalyser);

                recordAnalyser.fftSize = 1024; 
                recordAnalyser.smoothingTimeConstant = 0.3; 
                const bufferLength = recordAnalyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength); 

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    isRecording = false;
                    toggleRecordButton.textContent = 'Record';
                    toggleRecordButton.classList.remove('recording');
                    toggleRecordButton.disabled = false;
                    micSelect.disabled = false;
                    
                    if(streamInstance) {
                        streamInstance.getTracks().forEach(track => track.stop());
                        streamInstance = null; 
                    }
                    
                    playbackStatus.textContent = 'Processing audio...';
                    currentAudioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
                    const audioUrl = URL.createObjectURL(currentAudioBlob);
                    audioPlayback.src = audioUrl; 
                    
                    playbackStatus.textContent = 'Recording stopped. Playback available.';

                    if (recordVisualizerAnimationFrameId) {
                        cancelAnimationFrame(recordVisualizerAnimationFrameId);
                    }
                    visualizerBars.forEach(bar => bar.style.height = '0%');
                    
                    if(recordSourceNode) recordSourceNode.disconnect();
                    if (recordAudioContext && recordAudioContext.state !== 'closed') {
                        await recordAudioContext.close();
                    }
                    recordSourceNode = null; recordAnalyser = null; recordAudioContext = null;
                };

                mediaRecorder.start();
                isRecording = true;
                toggleRecordButton.textContent = 'Stop';
                toggleRecordButton.classList.add('recording');
                micSelect.disabled = true;
                playbackStatus.textContent = 'Recording...';
                
                drawRecordVisualizer(dataArray, bufferLength);

            } catch (err) {
                console.error('Error starting recording.', err);
                playbackStatus.textContent = `Error: ${err.name} - ${err.message}`;
                isRecording = false;
                toggleRecordButton.textContent = 'Record';
                toggleRecordButton.classList.remove('recording');
                toggleRecordButton.disabled = false;
                micSelect.disabled = false;
                if (streamInstance) { 
                    streamInstance.getTracks().forEach(track => track.stop());
                    streamInstance = null;
                }
                 if (recordAudioContext && recordAudioContext.state !== 'closed') {
                    await recordAudioContext.close();
                }
                recordSourceNode = null; recordAnalyser = null; recordAudioContext = null;
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop(); 
                toggleRecordButton.disabled = true; 
                playbackStatus.textContent = 'Stopping recording...';
            } else { 
                 isRecording = false;
                 toggleRecordButton.textContent = 'Record';
                 toggleRecordButton.classList.remove('recording');
                 toggleRecordButton.disabled = false;
                 micSelect.disabled = false;
                 if (streamInstance) { 
                    streamInstance.getTracks().forEach(track => track.stop());
                    streamInstance = null;
                }
            }
        }

        function drawRecordVisualizer(dataArray, bufferLength) { 
            if (!recordAnalyser) return; 
            recordAnalyser.getByteFrequencyData(dataArray); 

            for (let i = 0; i < NUM_BARS; i++) {
                const dataIndex = Math.floor(i * (bufferLength / NUM_BARS));
                const barHeight = (dataArray[dataIndex] / 255) * 100;
                if (visualizerBars[i]) {
                     visualizerBars[i].style.height = `${barHeight}%`;
                }
            }
            recordVisualizerAnimationFrameId = requestAnimationFrame(() => drawRecordVisualizer(dataArray, bufferLength)); 
        }
        
        function clearSpectrogram() {
            if (spectrogramCtx) {
                spectrogramCtx.fillStyle = 'rgba(0,0,0,0.3)'; 
                spectrogramCtx.fillRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
            }
        }

        audioPlayback.onloadeddata = async () => { 
            clearSpectrogram();
            if (currentAudioBlob) {
                await drawStaticSpectrogramWithScriptProcessor(currentAudioBlob);
            }
        };
        
        async function drawStaticSpectrogramWithScriptProcessor(audioBlobForSpectrogram) {
            const canvas = spectrogramCanvas;
            const sCtx = spectrogramCtx;
            setupSpectrogramCanvas(); 

            if (!audioBlobForSpectrogram) return;

            const staticAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
            try {
                const arrayBuffer = await audioBlobForSpectrogram.arrayBuffer();
                const audioBuffer = await staticAudioCtx.decodeAudioData(arrayBuffer);

                const analyser = staticAudioCtx.createAnalyser();
                analyser.fftSize = SPECTROGRAM_FFT_SIZE; 
                analyser.smoothingTimeConstant = 0; 

                const bufferSource = staticAudioCtx.createBufferSource();
                bufferSource.buffer = audioBuffer;

                const processorBufferSize = 4096; 
                const scriptProcessor = staticAudioCtx.createScriptProcessor(processorBufferSize, 1, 1);

                bufferSource.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(staticAudioCtx.destination); 

                const frequencyBinCount = analyser.frequencyBinCount;
                const frequencyData = new Uint8Array(frequencyBinCount);
                
                let samplesProcessedSoFar = 0;
                let nextXtoDraw = 0; 
                const totalSamplesInAudio = audioBuffer.length;
                const samplesPerPixelColumn = totalSamplesInAudio / canvas.width;


                scriptProcessor.onaudioprocess = function(audioProcessingEvent) {
                    if (nextXtoDraw >= canvas.width) { 
                        if (bufferSource.playbackState === bufferSource.PLAYING_STATE || bufferSource.playbackState === undefined) { 
                           try { bufferSource.stop(); } catch(e) { /* ignore */ }
                        }
                        return;
                    }

                    analyser.getByteFrequencyData(frequencyData);
                    const samplesInThisBlock = audioProcessingEvent.inputBuffer.getChannelData(0).length;
                    
                    let targetEndXPixelForThisBlock = Math.min(canvas.width, Math.ceil((samplesProcessedSoFar + samplesInThisBlock) / samplesPerPixelColumn));
                    
                    if ((samplesProcessedSoFar + samplesInThisBlock) >= totalSamplesInAudio) {
                        targetEndXPixelForThisBlock = canvas.width; 
                    }

                    for (let x = Math.floor(nextXtoDraw); x < Math.floor(targetEndXPixelForThisBlock); x++) {
                        if (x >= canvas.width) break; 
                        for (let i = 0; i < frequencyBinCount; i++) {
                            const value = frequencyData[i];
                            const normalizedValue = value / 255.0;
                            
                            const minLogVal = -3; 
                            const maxLogVal = 0;  
                            let logPercent = (Math.log10(normalizedValue + 0.001) - minLogVal) / (maxLogVal - minLogVal);
                            logPercent = Math.max(0, Math.min(1, logPercent)); 

                            const hue = 240 - (logPercent * 240); 
                            const saturation = '100%';
                            const lightness = (logPercent * 50) + 20 + '%'; 

                            const barHeightOnCanvas = canvas.height / frequencyBinCount;
                            const y = canvas.height - ((i + 1) * barHeightOnCanvas) ; 
                            
                            sCtx.fillStyle = `hsl(${hue}, ${saturation}, ${lightness})`;
                            sCtx.fillRect(x, y, 1, Math.max(1, barHeightOnCanvas)); 
                        }
                    }
                    nextXtoDraw = targetEndXPixelForThisBlock; 
                    samplesProcessedSoFar += samplesInThisBlock;

                    if (samplesProcessedSoFar >= totalSamplesInAudio) {
                         if (bufferSource.playbackState === bufferSource.PLAYING_STATE || bufferSource.playbackState === undefined) {
                           try { bufferSource.stop(); } catch(e) { /* ignore */ }
                        }
                    }
                };
                
                bufferSource.onended = async () => {
                    scriptProcessor.disconnect();
                    analyser.disconnect();
                    bufferSource.disconnect();
                    if (staticAudioCtx.state !== 'closed') {
                        await staticAudioCtx.close();
                    }
                };
                bufferSource.start(0);

            } catch (e) {
                console.error("Error drawing static spectrogram:", e);
                if (staticAudioCtx && staticAudioCtx.state !== 'closed') await staticAudioCtx.close();
                clearSpectrogram(); 
                sCtx.fillStyle = "rgba(255,255,255,0.7)";
                sCtx.font = "12px Segoe UI";
                sCtx.textAlign = "center";
                sCtx.fillText("Error rendering spectrogram", canvas.width / 2, canvas.height / 2);
            }
        }

        toggleRecordButton.addEventListener('click', handleToggleRecord);

        getMicrophones();
        setupSpectrogramCanvas(); 
        toggleRecordButton.disabled = true; 
        audioPlayback.src = ''; 

        // Set footer year and text dynamically
        const footerBar = document.getElementById('footerBar');
        const currentYear = new Date().getFullYear();
        footerBar.innerHTML = `© ${currentYear} <a href="https://mbdr.ai">Megan Ruthven</a> - Created April 2025 - <a href="https://github.com/mbdr-byte/mic-check">Source Code</a>`;

        // Event listeners for audio playback
        audioPlayback.addEventListener('play', function() {
            sendGAEvent('playback_action', {
                'event_category': 'engagement',
                'event_label': 'Playback Started',
                'action': 'play_pressed'
            });
        });
        
        audioPlayback.addEventListener('pause', function() {
            sendGAEvent('playback_action', {
                'event_category': 'engagement',
                'event_label': 'Playback Paused',
                'action': 'pause_pressed'
            });
        });
        
        audioPlayback.addEventListener('ended', function() {
            sendGAEvent('playback_action', {
                'event_category': 'engagement',
                'event_label': 'Playback Completed',
                'action': 'playback_ended'
            });
        });
        
        // Track microphone selection
        micSelect.addEventListener('change', function() {
            sendGAEvent('mic_selection', {
                'event_category': 'settings',
                'event_label': 'Microphone Changed',
                'action': 'mic_selected',
                'mic_label': this.options[this.selectedIndex].text
            });
        });
        
        // Track page view duration
        let pageStartTime = Date.now();
        window.addEventListener('beforeunload', function() {
            const durationSeconds = Math.floor((Date.now() - pageStartTime) / 1000);
            sendGAEvent('user_engagement', {
                'event_category': 'engagement',
                'event_label': 'Page View Duration',
                'action': 'page_exit',
                'duration_seconds': durationSeconds
            });
        });

        // Consent Banner Logic
        const consentBanner = document.getElementById('consentBanner');
        const acceptConsentButton = document.getElementById('acceptConsentButton');
        const declineConsentButton = document.getElementById('declineConsentButton');
        const consentKey = 'user_consent_preference_v1'; // Added _v1 for potential future changes

        function setConsent(granted) {
            const consentStatus = granted ? 'granted' : 'denied';
            gtag('consent', 'update', {
                'analytics_storage': consentStatus,
                'ad_storage': consentStatus // Assuming ad_storage follows analytics_storage
            });
            localStorage.setItem(consentKey, consentStatus);
            console.log(`Consent set to: ${consentStatus}`);
            consentBanner.classList.remove('show');
            // After the transition to hidden, set display: none
            setTimeout(() => {
                 if (!consentBanner.classList.contains('show')) { // Check if it's truly meant to be hidden
                    consentBanner.style.display = 'none';
                 }
            }, 600); // Slightly longer than CSS transition (0.5s)
        }

        acceptConsentButton.addEventListener('click', () => {
            setConsent(true);
        });

        declineConsentButton.addEventListener('click', () => {
            setConsent(false);
        });

        function checkConsent() {
            const savedConsent = localStorage.getItem(consentKey);
            if (savedConsent) {
                console.log(`Found saved consent: ${savedConsent}`);
                // If consent choice already made, ensure banner is not displayed
                consentBanner.style.display = 'none'; 
            } else {
                console.log('No saved consent found. Displaying banner.');
                // Banner is display:flex by default (from CSS), but opacity 0 and translated out.
                // We need to trigger the transition to opacity 1 and transformY(0).
                setTimeout(() => {
                    // The double rAF is to ensure the browser is ready for the transition after the timeout.
                    requestAnimationFrame(() => { 
                         requestAnimationFrame(() => { 
                            consentBanner.classList.add('show');
                         });
                    });
                }, 500); // Delay showing the banner slightly
            }
        }

        // Initialize
        checkConsent();
        
        // Privacy Policy Modal Logic
        const privacyPolicyLink = document.getElementById('privacyPolicyLink');
        const privacyModal = document.getElementById('privacyModal');
        const closePrivacyModal = document.getElementById('closePrivacyModal');
        
        privacyPolicyLink.addEventListener('click', function() {
            privacyModal.style.display = 'block';
            sendGAEvent('privacy_action', {
                'event_category': 'navigation',
                'event_label': 'Privacy Policy Opened',
                'action': 'view_policy'
            });
        });
        
        closePrivacyModal.addEventListener('click', function() {
            privacyModal.style.display = 'none';
        });
        
        window.addEventListener('click', function(event) {
            if (event.target === privacyModal) {
                privacyModal.style.display = 'none';
            }
        });
        
        // Additional GA4 Events for consent actions
        acceptConsentButton.addEventListener('click', function() {
            sendGAEvent('consent_action', {
                'event_category': 'privacy',
                'event_label': 'Consent Accepted',
                'action': 'accept_cookies'
            });
        });
        
        declineConsentButton.addEventListener('click', function() {
            sendGAEvent('consent_action', {
                'event_category': 'privacy',
                'event_label': 'Consent Declined',
                'action': 'decline_cookies'
            });
        });
        
        // Track spectrogram viewing
        audioPlayback.addEventListener('loadeddata', function() {
            sendGAEvent('audio_processing', {
                'event_category': 'feature_usage',
                'event_label': 'Spectrogram Generated',
                'action': 'view_spectrogram'
            });
        });
        
        // Track initial page load
        document.addEventListener('DOMContentLoaded', function() {
            sendGAEvent('page_view', {
                'event_category': 'engagement',
                'event_label': 'Initial Load',
                'action': 'page_loaded',
                'page_title': document.title
            });
        });
        
    </script>
</body>
</html>
